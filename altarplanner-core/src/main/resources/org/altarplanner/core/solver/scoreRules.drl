package org.altarplanner.core.solver;
dialect  "java"

import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScoreHolder;

import org.altarplanner.core.domain.request.*;
import org.altarplanner.core.domain.Server;
import org.altarplanner.core.domain.Service;
import java.time.temporal.ChronoUnit;

global HardSoftScoreHolder scoreHolder;

// ############################################################################
// Hard constraints
// ############################################################################

rule "oneServicePerDay"
    when
        Service($id : id, $server : server != null, $date : mass.date)
        Service(mass.date == $date, id > $id, server == $server)
    then
        scoreHolder.addHardConstraintMatch(kcontext, -1);
end

rule "notEnoughExp"
    when
        Service(server != null, server.year > type.maxYear)
    then
        scoreHolder.addHardConstraintMatch(kcontext, -1);
end

rule "dateOffRequest"
    when
        DateOffRequest($server : key, $date : value)
        Service(server == $server, mass.date == $date)
    then
        scoreHolder.addHardConstraintMatch(kcontext, -1);
end

rule "serviceTypeOffRequest"
    when
        ServiceTypeOffRequest($server : key, $serviceType : value)
        Service(server == $server, type == $serviceType)
    then
        scoreHolder.addHardConstraintMatch(kcontext, -1);
end

rule "dateTimeOnRequest"
    when
        DateTimeOnRequest($server : key, $date : value.toLocalDate(), $time : value.toLocalTime())
        Service(mass.date == $date, mass.time == $time)
        not Service(server == $server, mass.date == $date, mass.time == $time)
    then
        scoreHolder.addHardConstraintMatch(kcontext, -1);
end

// ############################################################################
// Soft constraints
// ############################################################################

rule "pairRequest"
    when
        PairRequest($server : key, $pairedWith : value)
        Service(server == $server, $mass : mass)
        not Service(server == $pairedWith, mass == $mass)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, -10);
end

rule "maximizeIntervals"
    when
        Service($server : server != null, $date1 : mass.date)
        Service(server == $server, $date2 : mass.date > $date1)
        not Service(server == $server, $date1 < mass.date, mass.date < $date2)
    then
        long softWeight = - 14 / ChronoUnit.DAYS.between($date1, $date2);
        scoreHolder.addSoftConstraintMatch(kcontext, Math.toIntExact(softWeight));
end

rule "tooMuchExp"
    when
        Service(server != null, $diff : (type.minYear - server.year) > 0)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, - 5 * $diff);
end

rule "minimizeServices"
    when
        $server : Server()
        accumulate(
            $assignment : Service(server == $server);
            $total : count($assignment);
            $total > 0
        )
    then
        int totalInt = $total.intValue();
        scoreHolder.addSoftConstraintMatch(kcontext, - totalInt * totalInt);
end