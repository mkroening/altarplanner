package org.altarplanner.core.solver;
dialect  "java"

import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScoreHolder;

import org.altarplanner.core.domain.request.*;
import org.altarplanner.core.domain.Service
import java.time.temporal.ChronoUnit;

global HardSoftScoreHolder scoreHolder;

// ############################################################################
// Hard constraints
// ############################################################################

rule "oneServicePerDay"
    when
        Service($id : id, $server : server != null, $date : mass.date)
        Service(mass.date == $date, id > $id, server == $server)
    then
        scoreHolder.addHardConstraintMatch(kcontext, -1);
end

rule "notEnoughExperience"
    when
        Service(server != null, (mass.date.year - server.year) < type.minExp)
    then
        scoreHolder.addHardConstraintMatch(kcontext, -1);
end

rule "dateOffRequest"
    when
        DateOffRequest($server : server, $date : date)
        Service(server == $server, mass.date == $date)
    then
        scoreHolder.addHardConstraintMatch(kcontext, -1);
end

rule "dayOffRequest"
    when
        DayOffRequest($server : server, $day : day)
        Service(server == $server, mass.date.dayOfWeek == $day)
    then
        scoreHolder.addHardConstraintMatch(kcontext, -1);
end

rule "serviceTypeOffRequest"
    when
        ServiceTypeOffRequest($server : server, $serviceType : serviceType)
        Service(server == $server, type == $serviceType)
    then
        scoreHolder.addHardConstraintMatch(kcontext, -1);
end

rule "dateTimeOnRequest"
    when
        DateTimeOnRequest($server : server, $date : dateTime.toLocalDate(), $time : dateTime.toLocalTime())
        Service(mass.date == $date, mass.time == $time)
        not Service(server == $server, mass.date == $date, mass.time == $time)
    then
        scoreHolder.addHardConstraintMatch(kcontext, -1);
end

// ############################################################################
// Soft constraints
// ############################################################################

// TODO: HardConstraint breaks Construction (implement dual move?)
rule "pairRequest"
    when
        PairRequest($server : server, $pairedWith : pairedWith)
        Service(server == $server, $mass : mass)
        not Service(server == $pairedWith, mass == $mass)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, -1);
end

rule "maximizeIntervals"
    when
        Service($server : server != null, $date1 : mass.date)
        Service(server == $server, $date2 : mass.date > $date1)
        not Service(server == $server, $date1 < mass.date, mass.date < $date2)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, - 14 / (int) ChronoUnit.DAYS.between($date1, $date2));
end